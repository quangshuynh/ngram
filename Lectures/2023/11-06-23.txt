Week 11 password: LinkedList
 
Sequences so far
	- Strings: Sequences of characters
	- Ranges: Sequences of integers
	- Files: Sequences of lines
	-  Lists: Sequences of anything
	- Dictionaries: Sequences of keys
		- You can use the value() function to get a sequence of values from a dictionary
	- Today, we are going to examine the idea of building our own sequences
		- One important drawback is that our sequences won't work with for loops

- Linked lists
	- Elements are not stored in a contiguous block of memory as they are in an array
	- Instead, each element is stored as a node
		- Each node contains two attributes:
			- A value
			- A reference to the first node in the rest of the list
	- ![[linked list.png]]

- Nested list diagrams
	- Given a list containing the values 10, 5 and 3, one way to visualizing this list is with a nested list diagram
		- Each node in the list is represented as a box
		- Each box contains the value stored by that node as well as the rest of the list
			- The rest in the last node is None because there are no other nodes
				- ![[nested list diagrams.png]]

- Box-and-pointer list diagrams
	- Given a list containing the values 10, 5 and 3, another way to visualize this list is with a box-and-pointer list diagram
		- Each node in the list is again represented as a box
		- The value is in the left half of the box
		- The right half of the box contains an arrow that points to the rest of the list
			- The last value points to None because there are no other nodes
				- ![[box and pointer.png]]

- Singly Linked Node: Immutable
	- Defining the node will use a Dataclass:
		- ![[Pasted image 20231106080943.png]]
	- Frozen: Makes the node immutable after creation
	- Any: Means the value can be of any type
	- Union: Defines a set of types for the value

- Destructive vs Non-destructive functions
	- Sometimes we need to add elements to or remove elements from a linked list
	- There are two approaches that we could take to implement these features
	- The *destructive* approach modifies the list by adding or removing nodes in place
	- The *non-destructive* approach creates a copy of the list with nodes that have been added or removed
	- Because our Node structure is immutable, we will need to remove the frozen attribute so that we can modify the stacks

- Doing it both ways:
	- Immutable linked list
		- Frozen nodes
		- Non-destructive: Functions create new lists
		- Uses recursive functions
		- Similar to sorted(lst)
	- Mutable linked list
		- Non-frozen nodes
		- Destructive: Functions change the underlying list
		- Uses iterative functions
		- Similar to lst.sort()

- A template for structural recursion
	- The node is a recursive structure
	- If therefore may come as no surprise that such a structure works naturally with recursive functions
	- There is a template that such functions usually follow
		- ![[structural recursion template.png]]

- Recursive to string
	- Our first function will convert the list to a String for printing
	- We will adapt the recursive template
		- ![[recursive to string.png]]
			- Base case:
				- Empty list
				- Return acc
			- Unit of work
				- Append current value to string
			- The rest
				- Convert rest of list to a string
	
	- To String: "[99, 100, 101]"
		- ![[Pasted image 20231106081731.png]]
	
	- Attempt 1:
		- ![[recursive to string attempt 1.png]]
	
	- Attempt 2:
		- ![[Pasted image 20231106081821.png]]
	
	- Attempt 3 (final)
		- ![[Pasted image 20231106081841.png]]
	
	- Output:
		- ![[Pasted image 20231106081952.png]]

- Recursive append
	- This function will add new values to the end of the list
	- The recursive template will be used
		- ![[Pasted image 20231106082107.png]]
	- Input and output
		- ![[Pasted image 20231106082130.png]]
	- Function append
		- ![[Pasted image 20231106082144.png]]
	- Memory diagram
		- ![[Pasted image 20231106082220.png]]
		- ![[Pasted image 20231106082236.png]]

- Insertion
	- Next, we'd like to insert a new value into some index in the list
	- We will do this by creating a copy of the list with a new LinkNode containing the new value
	- Box-and-pointer diagram after inserting the value 5 at index 2:
		- ![[Pasted image 20231106082408.png]]
	- Initialization
		- ![[Pasted image 20231106082453.png]]
	- Attempt 1
		- ![[Pasted image 20231106082532.png]]
	- Attempt 2 (final)
		- ![[Pasted image 20231106082548.png]]

- Recursive remove
	- Our next function will remove the first instance of a linked target value if it is contained somewhere in the linked list
	- We will adapt the recursive template again
		- ![[Pasted image 20231106083936.png]]
	- Getting and setting
		- Head (First node, count = 0)
			- ![[Pasted image 20231106082745.png]]
		- Next node (second node, count = 1)
			- ![[Pasted image 20231106082805.png]]
		- Next node (Third node, count = 2)
			- ![[Pasted image 20231106082859.png]]
		- Next node (Fourth node, count = 3)
			- ![[Pasted image 20231106082920.png]]

- Recursive get_value
	- Our next function will return the value contained in the node at a specified index
	- Recursive template will be adapted
		- ![[Pasted image 20231106083952.png]]
	- Substitution trace: _get_value()
		- Given a list containing the values 5, 6, 7, let's write out the substitution trace for _get_value(lst, 2)
			- ![[Pasted image 20231106083258.png]]

- Recursive set_value
	- Our next function will set the value contained in the node at a specified index
		- Recursive template adapted
		- ![[Pasted image 20231106084009.png]]

- Recursive contains
	- Our next function will determine whether or not a given target value is contained somewhere in the linked list
	-  Recursive template adapted
		- ![[Pasted image 20231106084023.png]]

- Recursive index of 
	- Our next function will return the index of the node with a specified target value or -1 if the value is not in the list
	- Think of the index as the distance from the first LinkNode in the list
	- This is a count of the number of times that we need to follow rest until we find the right code
	- The first node is a distance of 0 (from itself). And the 2nd is 1, the 3rd is 2, etc.
	-  Recursive template adapted
		- ![[Pasted image 20231106084037.png]]

- Recursive concatenate
	- The next function that we will tackle is concatenation
		- Creates a new list with the nodes from one list appended onto the end of the other
		- Of course, because our LinkedNodes are immutable, we will need to create a copy of the original lists that contains the nodes from both
		- Recursive template adapted
			- ![[Pasted image 20231106084421.png]]
	- Concatenation
		- ![[Pasted image 20231106084505.png]]

- Tail recursive template
	- Has an additional accumulator
	- Parameter acc passes partial results to subsequent recursive calls
		- ![[Pasted image 20231106084529.png]]

- Array list
	- Python's built=in list is an array based implementation
	- Elements are stored in a block of memory
	- The array list maintains:
		- Size (current number of elements)
		- Capacity (how many elements can be stored)
	- Once the capacity is exceeded, a bigger array is created

- Linked list vs Array list complexities
	- ![[Pasted image 20231106084810.png]]

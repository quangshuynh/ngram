- Weekly password: HashPotato 

- Hashing
	- A hash function is a one-way function that, given an arbitrary input value, produces a number as output
		- That's a lot of information right there. Let's break it down
	- A one-way function is one that works in one direction
		- Given some input value, it will produce an output value (i.e. an integer)
		- But given an output value, the function cannot determine the original input
	- A hash function produces a numeric value called a hash code as output
	- Given the same input value, a hash function will always produce the same output value
		- Though this may change from one run to the next, it will always be consistent within one process
	- This process is called hashing
		- Not all types in Python are hashable
	- A hashing data structure, like a set or dictionary, uses a hash function to convert the values into hash codes
		- These hash codes are used to store elements in a specific index in an array in constant time
	- The Python set and dictionary are hashing data structures built on top of an array
	- A hash function is used to convert arbitrary values into integers, which can then be used to find an index in the array
		- ![[Pasted image 20231204080548.png]]

- Hash functions
	- Assume that an empty list is created that is large enough to store N students
	- Because the student IDs include letters as well as numbers, we can't directly use them as indexes in the array
	- Instead, some kind of hashing function is needed: a constant time operation that, given a student ID as input, produces a number that can be used as the index into which the student should be stored
	- Later, when the student needs to be retrieved, the hashing function can be used with the ID again to find the student's position in the list
	- This means that, with the right hashing function, adding and retrieving students from the list would be an O(1) operation
		- ![[Pasted image 20231204080823.png]]

- Ascii table
	- ![[Pasted image 20231204080841.png]]

- Activity: Hashing student IDs
	- Determine a hash function to translate strings into hash codes. Then use it to determine the hashcode for the IDs listed below
		- ![[Pasted image 20231204080949.png]]
	- Let's assume our hash function can translate each unique ID into a unique index in the array. Given a 3-letter, 4-digit ID like the one that RIT uses:
	- 26^3 * 10^4 = 175,760,000:
		- The minimum size required to store all possible student IDs
	- ~20,000:
		- The number of students enrolled at any one in a relatively large university (e.g. RIT)?
	- 8788 : 1:
		- The ratio of empty spaces to students in the array

- Space vs. Time Complexity
	- We can use student ID as an index in the Python list
	- This means that given an ID, we can fetch that student from the array in constant time rather than doing a linear search! 
	- There is just one small very large problem
	- In order to use the student ID as an index, we need to allocate an array large enough to store any possible student ID
		- The number of possible IDs is 26^3 * 10^4 = 175,760,000
		- The ID "ZZZ9999" maps to index 175,759,999
	- That is approximately 8,788 empty spaces in the array for each that is occupied by one of RIT's ~20,000 students
	- In general, when time complexity & space complexity are in competition, we prefer to sacrifice space complexity for better time complexity
	- But using 9000 times the space needed to actually store our students is absurd

- There has to be a better way
	- I think we can all agree that using an array with 176 million available indices to store 20 thousand students is silliness.
	- It’s OK to allocate some additional space, but within reason.
		- And we’d definitely like to get that constant time performance when accessing the array.
	- What if we could somehow translate the potentially very large numbers that are returned by our hashing function into an index that would fit into a much smaller array?
		- And what if the size of the array changes? 

- Indexing function
	- An indexing function is inserted between the output from the hash function and the array
	- Each student ID is first hashed to translate it into a numeric hashcode, which may be an arbitrarily large number
	- The hashcode is then used an input to an *indexing function* that maps it onto an index that will actually fit within a much smaller array
		- ![[Pasted image 20231204081751.png]]

- Activity: Indexing student IDs
	- Assuming your array has the capacity to hold 10 students, use an indexing function (hashcode % capacity) to translate the following hash codes into an index in the array
		- ![[Pasted image 20231204081926.png]]

- Collisions
	- When we try to store two different students in the same location in the array, this is called a collision
	- There are mechanisms for handling collisions when they occur
	- In the best case scenario, our hashing function and indexing function work together to put each student in its own index in the array
		- ![[Pasted image 20231204082113.png]]

- Open addressing
	- It is not acceptable to simply overwrite (and lose) one student that is stored in the array when another student is indexed to the same location
	- The array is sparse, which means that there are a good number of empty spaces in the array
	- Why not start at the index & search for the next empty space in the array
	- This technique is called open addressing
		- ![[Pasted image 20231204082324.png]]

- Activity: Open addressing
	- Determine the index for each ID, and then write it into the table. Use open addressing to resolve conflicts
		- ![[Pasted image 20231204082520.png]]

- Activity: Put function
	- Create a put(array, value) function so that it uses open addressing
		- ![[Pasted image 20231204082605.png]]

- Activity: Retrieving students I
	- Given each Student ID below, find the corresponding student in the array
		- ![[Pasted image 20231204082653.png]]

- Activity: Retrieving students II
	- Given each Student ID below, find the corresponding student in the array
		- ![[Pasted image 20231204082819.png]]

- Entries:
	- Collisions result when more than one key is indexed into the same 
	- Open addressing allows the array to gracefully handle collisions by storing the value associated with the key at a different index
	- However, this means that when the key is later used to retrieve the value, the value may not be found at the key's index
	- We will need to search for the correct value. The only way to know that we've found it is to compare the key used to retrieve the value with the key originally used to store it
		- Dataclass
			- ![[Pasted image 20231204083220.png]]

- Activity: Adding students III
	- Store each student as an entry (key/value) pair. Use the student ID as the key and the student name as the value. Refer to the earlier exercise for index values.
		- ![[Pasted image 20231204083323.png]]

- Activity: Put Function III
	- Update the put(array, key, value) function to use the Entry structure
		- ![[Pasted image 20231204083402.png]]

- Activity: Get Function II
	- Update the get(array, key) function to use open addressing entries
		- ![[Pasted image 20231204083442.png]]

- A Super Array
	- If everything has gone according to plan, we now have a super array
	- Adding an element to the array is constant time!
		- Except when it's nit
	- Retrieving an element from the array is constant time!
		- Except when it's not
	- When is it not?
		- If everything goes perfectly, we never have a collision
		- Unfortunately, every time a collision occurs, we need to do a linear search
		- If the linear search gets long enough, it may even approach linear time - O(N)
	- The more often that collisions occur, the worse that our super array performs

- Worst case complexity of Put/Get
	- Each time a collision occurs, the put function performs a linear search to find the next open address
	- In the extreme case, the only open address is the one right before the key's index, and so the array entire is searched
	- This means that the put operation has a complexity of O(n)
	- Similarly, when we try to get the value back out, another linear search is performed over the entire array
	- Meaning that the get operation also has a complexity of O(n)
	- The only way to avoid this is to avoid collisions as much as possible
		- ![[Pasted image 20231204084003.png]]


- Avoiding collisions
	- There are two reasons that collisions may occur more frequently:
		- A poor hash function
		- The array is almost full
	- A poor hashing function often produces the same hashcode values for lots of different keys
		- A perfect hashing function would produce a unique hash code for every possible keys 
	- An array that is almost full mean that, even if the hashing function is good, it is likely a key will be indexed into a space that is already occupied by another entry
		- The only way to compensate for this is to create a new and bigger array

- Increasing capacity
	- Remember that the size of the super array is the number of elements that it is currently holding, but the capacity of the array is the total number of elements can possibly fit
	- The load factor is the measure of fullness of the array; it is the ratio of the size to the capacity
	- When the load factor exceeds a certain threshold, collisions are much more likely to occur
		- This means that it is time to resize the array

- Copying elements
	- ![[Pasted image 20231204084712.png]]

- Activity: Rehashing
	- When the array is resized, the index for each entry needs to be computed again using the larger array's capacity. This process of computing new indexes is called rehashing
		- ![[Pasted image 20231204084814.png]]

- Rehashing
	- The process of increasing the size of a hashmap & redistributing the elements to new buckets based on their new hash values
	- Rehashing is necessary to improve the performance of the hash map and to prevent collisions caused by a high load factor
		- When the hashmap becomes full, the load factor increases
		- As the load factor increases, the number of collisions also increases, leading to poor performance
	- As a hashmap becomes full, the rate of collisions will increase. One way to alleviate this is to increase the size of the underlying data structure & rehash the existing values
		- ![[Pasted image 20231204085106.png]]

- Rehashing code:
	- Create a new hashmap which is double the size of the existing map
	- All existing map entries must be rehashed into the new map because their hash locations will change based on the new size of the map
		- ![[Pasted image 20231204085216.png]]

- Handling collisions: Chaining
	- Rather than storing individual entries at each index in the array, a list of entries is stored instead
	- If two or more keys are indexed into the same location, the entries are added to the list
	- This means that, when a key is used to retrieve a value, the list at the corresponding index must be searched for the entry with the correct key
	- The mechanism for resolving collisions is called chaining
		- ![[Pasted image 20231204085415.png]]

- Activity: Chaining
	- Determine the index for each ID, then add it to the table. Use chaining to resolve conflicts
		- ![[Pasted image 20231204085652.png]]

- Complexity of chaining
	- Using a list of entries means that a virtually unlimited number of key/value pairs can be stored in the array
	- However, the index of each array is still a function of the capacity of the table. meaning more values are added to the array which means it is more likely a collision will occur
	- The more collisions that occur, the longer the lists at each index will become
	- The complexity of putting into or getting from the array will increase as the lists of entries get longer
	- Resizing & rehashing are still necessary
		- ![[Pasted image 20231204090029.png]]

- Hash table
	- Sometimes called a dictionary or hash map
	- Hash tables store key/value pairs as entries
	- Keys must be hashable meaning they can be translated into numeric hash codes
		- Not all keys are strings, many Python types define their own hash functions
		- If you try to use a type that is not hashable in a Python dictionary, an error will occur
	- Hash tables provide put & get operations with constant time performance
		- This requires the load factor be monitored to avoid collisions
		- If the load factor crosses a certain threshold, the hash table is resized & rehashed

- Collisions
	- There is an infinite number of possible inputs to a hash function, but there are a finite number of possible outputs
		- The range of hash code values is limited by the size of an integer in Python 
		- This means that it is not only possible, but likely that two different values will have the same hash code
		- This is one reason why hash codes only work one-way
	- The data structure used to store the hashed values is very small compared to the range of possible hash codes
		- This is to conserve memory, we dont want to allocate an array big enough to hold billions of elements if we dont need to
		- The hash code must be converted into an index in the array (using a modulo with the size of the array)
	- Together, duplicate hash codes and a limited number of available indexes in the array mean that it is inevitable that two values will be hashed to the same index
	- When two different values are hashed into the same index in an array, this is referred to as a collision

- Hash functions
	- A good hash function has the following characteristics
		- It is fast meaning that it runs in constant time 
		- It is consistent because the hash function is used to store & retrieve values, it must always return the same hash code for the same input
		- It minimizes collisions by ensuring to two different input values will result in two different hash codes
			- ![[Pasted image 20231204091816.png]]
